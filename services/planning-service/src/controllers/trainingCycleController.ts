import { Request, Response, NextFunction } from 'express';
import * as CycleRepo from '../repositories/trainingCycleRepository';
import * as SeasonRepo from '../repositories/seasonRepository';
import { AuthenticationError, NotFoundError, ValidationError, ConflictError } from '../errors/serviceErrors';
import { CreateTrainingCycleInput, UpdateTrainingCycleInput } from '../validation/trainingCycleSchemas';

export const getCycles = async (req: Request, res: Response, next: NextFunction) => {
  const { phaseId } = req.params;
  const orgId = req.user?.organizationId;
  if (!orgId) return next(new AuthenticationError('Organization context missing'));
  try {
    const cycles = await CycleRepo.findCyclesByPhaseId(phaseId, orgId);
    res.status(200).json({ success: true, data: cycles });
  } catch (err) {
    next(err);
  }
};

export const getCycleById = async (req: Request, res: Response, next: NextFunction) => {
  const { cycleId } = req.params;
  const orgId = req.user?.organizationId;
  if (!orgId) return next(new AuthenticationError('Organization context missing'));
  try {
    const cycle = await CycleRepo.findCycleById(cycleId, orgId);
    if (!cycle) throw new NotFoundError('Training cycle not found');
    res.status(200).json({ success: true, data: cycle });
  } catch (err) {
    next(err);
  }
};

export const createCycle = async (req: Request, res: Response, next: NextFunction) => {
  const orgId = req.user?.organizationId;
  const userId = req.user?.id;
  if (!orgId || !userId) return next(new AuthenticationError('User context missing'));
  const { seasonId, phaseId } = req.params;
  const data = req.body as CreateTrainingCycleInput;
  try {
    // --- Validation helpers ---
    const phase = await SeasonRepo.findPhaseById(phaseId, orgId);
    if (!phase) {
      throw new NotFoundError('Parent season phase not found');
    }

    const newStart = new Date(data.startDate);
    const newEnd = new Date(data.endDate);
    if (newStart >= newEnd) {
      throw new ValidationError('startDate must be before endDate');
    }
    if (newStart < new Date(phase.startDate) || newEnd > new Date(phase.endDate)) {
      throw new ValidationError('Training cycle dates must be within the phase start and end dates');
    }

    const existingCycles = await CycleRepo.findCyclesByPhaseId(phaseId, orgId);
    const overlaps = existingCycles.some(c => {
      const cStart = new Date(c.startDate);
      const cEnd = new Date(c.endDate);
      return newStart < cEnd && newEnd > cStart;
    });
    if (overlaps) {
      throw new ConflictError('Training cycle dates overlap with an existing cycle in this phase');
    }

    const newCycle = await CycleRepo.createCycle({
      organizationId: orgId,
      seasonId,
      phaseId,
      name: data.name,
      startDate: new Date(data.startDate),
      endDate: new Date(data.endDate),
      description: data.description,
      order: data.order,
      createdAt: new Date(),
      updatedAt: new Date(),
      id: '' as any, // will be generated by DB
    } as any);
    res.status(201).json({ success: true, data: newCycle });
  } catch (err) {
    next(err);
  }
};

export const updateCycle = async (req: Request, res: Response, next: NextFunction) => {
  const orgId = req.user?.organizationId;
  if (!orgId) return next(new AuthenticationError('Org context missing'));
  const { cycleId } = req.params;
  const data = req.body as UpdateTrainingCycleInput;
  try {
    // Fetch current cycle and phase for validation
    const existing = await CycleRepo.findCycleById(cycleId, orgId);
    if (!existing) throw new NotFoundError('Training cycle not found');

    let newStart = existing.startDate;
    let newEnd = existing.endDate;
    if (data.startDate) newStart = new Date(data.startDate);
    if (data.endDate) newEnd = new Date(data.endDate);
    if (newStart >= newEnd) {
      throw new ValidationError('startDate must be before endDate');
    }

    const phase = await SeasonRepo.findPhaseById(existing.phaseId, orgId);
    if (!phase) throw new NotFoundError('Parent phase not found');
    if (newStart < new Date(phase.startDate) || newEnd > new Date(phase.endDate)) {
      throw new ValidationError('Training cycle dates must be within the phase start and end dates');
    }

    const otherCycles = (await CycleRepo.findCyclesByPhaseId(existing.phaseId, orgId)).filter(c => c.id !== cycleId);
    const overlaps = otherCycles.some(c => {
      const cStart = new Date(c.startDate);
      const cEnd = new Date(c.endDate);
      return newStart < cEnd && newEnd > cStart;
    });
    if (overlaps) {
      throw new ConflictError('Updated cycle dates overlap with another cycle');
    }

    const updated = await CycleRepo.updateCycle(cycleId, orgId, {
      ...data,
      startDate: data.startDate ? new Date(data.startDate) : undefined,
      endDate: data.endDate ? new Date(data.endDate) : undefined,
    });
    if (!updated) throw new NotFoundError('Training cycle not found or no fields to update');
    res.status(200).json({ success: true, data: updated });
  } catch (err) {
    next(err);
  }
};

export const deleteCycle = async (req: Request, res: Response, next: NextFunction) => {
  const orgId = req.user?.organizationId;
  const { cycleId } = req.params;
  if (!orgId) return next(new AuthenticationError('Org context missing'));
  try {
    const deleted = await CycleRepo.deleteCycle(cycleId, orgId);
    if (!deleted) throw new NotFoundError('Training cycle not found');
    res.status(200).json({ success: true });
  } catch (err) {
    next(err);
  }
}; 